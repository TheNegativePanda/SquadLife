on load:
    LoadYaml()

local function LoadYaml():
    load yaml "plugins/EnchantmentDowngrader/config.yml" as "config"
    if yaml "config" is empty:
        LoadDefaultValues("config")            

local function LoadDefaultValues(yaml: string):
    set yaml value "default" from {_yaml} to 2
    set comments of yaml node "default" from {_yaml} to "The default maximum level for all enchantments"
    set yaml value "enchantments.efficiency" from {_yaml} to 3
    set comments of yaml node "enchantments" from {_yaml} to "Format for overiding default max enchant value is %%name of enchantment%%: %%level of enchantment%%" and "setting the level to 0 disables the enchantment completely"
    set yaml value "overrides.diamond_axe.sharpness" from {_yaml} to 1
    set comments of yaml node "overrides" from {_yaml} to "Format for overiding the global enchantment cap is", "%%item type%%: ", "%%name of enchantment%%: %%level of enchantment%%"
    save yaml {_yaml}

on inventory slot change:
    event-item != 0 airs
    if player's metadata value "slot=(%index of event-slot%)" isn't set:
        set player's metadata value "slot=(%index of event-slot%)" to now
    else if time since player's metadata value "slot=(%index of event-slot%)" >= 5 ticks:
        set player's metadata value "slot=(%index of event-slot%)" to now
        LoadYaml()
        if CorrectItem(event-item stack, yaml value "default" of "config") != event-item stack:
            wait 1 tick
            set slot (index of event-slot) of player's inventory to CorrectItem(event-item stack, yaml value "default" of "config")


local function CorrectItem(item: item stack, maxLevel: integer) :: item stack:
    set {_enchantments::*} to getModifiedEnchantments({_item}, {_maxLevel})
    set {_keepEnchantments::*} to enchantments of {_item} except {_enchantments::*}
    if {_enchantments::*} are not set:
        return {_item}
    disenchant {_item}
    enchant {_item} with {_keepEnchantments::*}
    loop {_enchantments::*}:
        enchant {_item} with loop-value
    return {_item}
    
local function getModifiedEnchantments(item: item stack, maxLevel: integer) :: enchantment types:
    LoadYaml()
    set {_itemType} to lower snake case "%type of {_item}%" 
    loop enchantments of {_item}:
        if any:
            yaml value "overrides.%{_itemType}%.%enchantment of loop-value%" from "config" is set
            yaml value "overrides.%{_itemType}%.default" from "config" is set
        then:
            if enchantment level of loop-value > yaml value "overrides.%{_itemType}%.%enchantment of loop-value%" from "config":
                set {_level} to yaml value "overrides.%{_itemType}%.%enchantment of loop-value%" from "config"
                add "%enchantment of loop-value% %{_level}%" parsed as enchantment type to {_enchantments::*}
            else:
                set {_level} to yaml value "overrides.%{_itemType}%.%enchantment of loop-value%" from "config"
                add "%enchantment of loop-value% %{_level}%" parsed as enchantment type to {_enchantments::*}
        else if enchantment level of loop-value > yaml value "enchantments.%enchantment of loop-value%" from "config":
            set {_level} to yaml value "enchantments.%enchantment of loop-value%" from "config"
            add "%enchantment of loop-value% %{_level}%" parsed as enchantment type to {_enchantments::*}
        else if all: 
            enchantment level of loop-value > {_maxLevel}
            yaml value "enchantments.%enchantment of loop-value%" from "config" is not set
        then:
            add "%enchantment of loop-value% %{_maxLevel}%" parsed as enchantment type to {_enchantments::*}
    return {_enchantments::*}

